"use strict";(self.webpackChunkcheatsheet=self.webpackChunkcheatsheet||[]).push([[5377],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8552:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={},r="JavaScript",l={unversionedId:"Toolbox/Languages/JavaScript",id:"Toolbox/Languages/JavaScript",title:"JavaScript",description:"ESNext",source:"@site/docs/Toolbox/Languages/JavaScript.md",sourceDirName:"Toolbox/Languages",slug:"/Toolbox/Languages/JavaScript",permalink:"/cheatsheet/docs/Toolbox/Languages/JavaScript",draft:!1,editUrl:"https://github.com/niqiukun/cheatsheet/blob/master/docs/Toolbox/Languages/JavaScript.md",tags:[],version:"current",frontMatter:{},sidebar:"toolboxSidebar",previous:{title:"HTML",permalink:"/cheatsheet/docs/Toolbox/Languages/HTML"},next:{title:"TypeScript",permalink:"/cheatsheet/docs/Toolbox/Languages/TypeScript"}},s={},p=[{value:"ESNext",id:"esnext",level:2},{value:"ES2022",id:"es2022",level:4},{value:"ES2021",id:"es2021",level:4},{value:"ES2020",id:"es2020",level:4},{value:"ES2019",id:"es2019",level:4},{value:"ES2018",id:"es2018",level:4},{value:"ES2017",id:"es2017",level:4},{value:"ES2016",id:"es2016",level:4},{value:"ES2015 (ES6)",id:"es2015-es6",level:4},{value:"This",id:"this",level:2},{value:"Contexts",id:"contexts",level:3},{value:"Apply, Bind and Call",id:"apply-bind-and-call",level:3},{value:"<code>apply(thisArg: any, argArray?: any[])</code>",id:"applythisarg-any-argarray-any",level:4},{value:"<code>call(thisArg: any, ...argArray: any[])</code>",id:"callthisarg-any-argarray-any",level:4},{value:"<code>bind(thisArg: any)</code>",id:"bindthisarg-any",level:4},{value:"Use Cases of Function Built-ins",id:"use-cases-of-function-built-ins",level:3},{value:"Inheritance with prototype",id:"inheritance-with-prototype",level:4},{value:"Wrapping a function",id:"wrapping-a-function",level:4},{value:"Prototype",id:"prototype",level:2},{value:"From Class to Prototype",id:"from-class-to-prototype",level:3},{value:"Constructors",id:"constructors",level:3},{value:"Initializing properties",id:"initializing-properties",level:4},{value:"Initializing methods",id:"initializing-methods",level:4},{value:"Inheritance Chains",id:"inheritance-chains",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Debounce and Throttle",id:"debounce-and-throttle",level:2},{value:"Debounce",id:"debounce",level:3},{value:"Throttle",id:"throttle",level:3},{value:"Currying",id:"currying",level:2},{value:"Behind the Scene",id:"behind-the-scene",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"The Event Loop",id:"the-event-loop",level:3},{value:"Runtime concepts",id:"runtime-concepts",level:4},{value:"The event loop",id:"the-event-loop-1",level:4}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"javascript"},"JavaScript"),(0,i.kt)("h2",{id:"esnext"},"ESNext"),(0,i.kt)("h4",{id:"es2022"},"ES2022"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Private properties and methods in classes"),(0,i.kt)("li",{parentName:"ul"},"Top-level await in modules"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Array.prototype.at()")," equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"arr[]"))),(0,i.kt)("h4",{id:"es2021"},"ES2021"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.prototype.replaceAll()")),(0,i.kt)("li",{parentName:"ul"},"Logical assignment operators: ",(0,i.kt)("inlineCode",{parentName:"li"},"||="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"&&="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"??=")),(0,i.kt)("li",{parentName:"ul"},"Numeric separator: ",(0,i.kt)("inlineCode",{parentName:"li"},"1_000_000")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Promise.any()"))),(0,i.kt)("h4",{id:"es2020"},"ES2020"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Nullish coalescing operator: ",(0,i.kt)("inlineCode",{parentName:"li"},"??")),(0,i.kt)("li",{parentName:"ul"},"Optional chaining operator: ",(0,i.kt)("inlineCode",{parentName:"li"},"?.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Promise.allSettled()")),(0,i.kt)("li",{parentName:"ul"},"Dynamic import via ",(0,i.kt)("inlineCode",{parentName:"li"},"import()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BigInt")," primitive type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"globalThis"))),(0,i.kt)("h4",{id:"es2019"},"ES2019"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Array.prototype.flat() / flatMap()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Object.fromEntries()"),": reverse of ",(0,i.kt)("inlineCode",{parentName:"li"},"Object.entries()")),(0,i.kt)("li",{parentName:"ul"},"Optional catch binding: parameter ",(0,i.kt)("inlineCode",{parentName:"li"},"error")," is optional after ",(0,i.kt)("inlineCode",{parentName:"li"},"catch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.prototype.trimStart() / trimEnd()"))),(0,i.kt)("h4",{id:"es2018"},"ES2018"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Object spread operator: ",(0,i.kt)("inlineCode",{parentName:"li"},"...")," for objects"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Promise.prototype.finally()")),(0,i.kt)("li",{parentName:"ul"},"Asynchronous iterators: ",(0,i.kt)("inlineCode",{parentName:"li"},"for async (... of ...)")),(0,i.kt)("li",{parentName:"ul"},"Asynchronous generators: ",(0,i.kt)("inlineCode",{parentName:"li"},"yield")," promises")),(0,i.kt)("h4",{id:"es2017"},"ES2017"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.prototype.padStart() / padEnd()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Object.values()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Object.entries()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"async")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"await"))),(0,i.kt)("h4",{id:"es2016"},"ES2016"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Exponentiation operator: ",(0,i.kt)("inlineCode",{parentName:"li"},"**")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Array.prototype.includes()"))),(0,i.kt)("h4",{id:"es2015-es6"},"ES2015 (ES6)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.prototype.startsWith() / endsWith() / includes() / repeat()")),(0,i.kt)("li",{parentName:"ul"},"Template literals: ",(0,i.kt)("inlineCode",{parentName:"li"},"`Hello %{name}`")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Symbol")," primitive type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"const")),(0,i.kt)("li",{parentName:"ul"},"Destructuring: ",(0,i.kt)("inlineCode",{parentName:"li"},"const { a, b } = obj")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"const [a, b] = arr")),(0,i.kt)("li",{parentName:"ul"},"Default function parameters: ",(0,i.kt)("inlineCode",{parentName:"li"},"function func(x, y=0) { ... }")),(0,i.kt)("li",{parentName:"ul"},"Rest parameters: ",(0,i.kt)("inlineCode",{parentName:"li"},"function func(a, ...restArgs) { ... }")),(0,i.kt)("li",{parentName:"ul"},"Spread operator: ",(0,i.kt)("inlineCode",{parentName:"li"},"...")," for iterables (arrays)"),(0,i.kt)("li",{parentName:"ul"},"Arrow functions: ",(0,i.kt)("inlineCode",{parentName:"li"},"(...) => { ... }"))),(0,i.kt)("admonition",{title:"Arrow Functions",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Unlike normal functions, arrow functions"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"do not have own ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," always refers to the context object of the outer scope."),(0,i.kt)("li",{parentName:"ul"},"do not support ",(0,i.kt)("inlineCode",{parentName:"li"},"call()")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"apply()"),"."),(0,i.kt)("li",{parentName:"ul"},"do not have ",(0,i.kt)("inlineCode",{parentName:"li"},"arguments")," variable."),(0,i.kt)("li",{parentName:"ul"},"do not have ",(0,i.kt)("inlineCode",{parentName:"li"},"prototype"),"."),(0,i.kt)("li",{parentName:"ul"},"cannot be constructors."))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Method definitions in objects: ",(0,i.kt)("inlineCode",{parentName:"li"},"{ myMethod(x, y) {...} }")),(0,i.kt)("li",{parentName:"ul"},"Property value shorthands: ",(0,i.kt)("inlineCode",{parentName:"li"},"const obj = { a, b }")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"{ a: a, b: b }")),(0,i.kt)("li",{parentName:"ul"},"Computed property keys in objects: ",(0,i.kt)("inlineCode",{parentName:"li"},"{ [key]: ... }")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Object.assign()")),(0,i.kt)("li",{parentName:"ul"},"Classes"),(0,i.kt)("li",{parentName:"ul"},"Modules: ",(0,i.kt)("inlineCode",{parentName:"li"},"export")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"import")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for ... of ...")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Array.from() / to()"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Array.prototype.entries() / keys() / values() / find() / findIndex() / copyWithin() / fill()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Map"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"WeakMap"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Set"),": maps, weakMaps and sets"),(0,i.kt)("li",{parentName:"ul"},"Typed arrays"),(0,i.kt)("li",{parentName:"ul"},"Iterables and Iterators"),(0,i.kt)("li",{parentName:"ul"},"Generators"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Promise"),": promises"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Proxy"),": proxies")),(0,i.kt)("h2",{id:"this"},"This"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"this")," is the context object that points to different objects depending on the context."),(0,i.kt)("h3",{id:"contexts"},"Contexts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Global")),(0,i.kt)("p",{parentName:"li"},"Without any context, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," refers to the global object: the ",(0,i.kt)("inlineCode",{parentName:"p"},"globalThis")," property in NodeJS, or ",(0,i.kt)("inlineCode",{parentName:"p"},"window")," in browsers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Function")),(0,i.kt)("p",{parentName:"li"},"In a function, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," depends on how the function is called. If the function is called directly, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," also refers to the global object. In a constructor called with ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," keyword, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," refers to the newly created object instead. In ",(0,i.kt)("a",{parentName:"p",href:"#apply-bind-and-call"},"a function called with ",(0,i.kt)("inlineCode",{parentName:"a"},"call")," or ",(0,i.kt)("inlineCode",{parentName:"a"},"apply")," or a bound function created with ",(0,i.kt)("inlineCode",{parentName:"a"},"bind")),", ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," depends on the actual function parameters."),(0,i.kt)("p",{parentName:"li"},"If the function is a method of an object, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," refers to the object itself."),(0,i.kt)("p",{parentName:"li"},"Note that in an arrow function, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," takes the value of its outer context (",(0,i.kt)("inlineCode",{parentName:"p"},"this")," outside the function). This is determined when the arrow function is created and is regardless of when it is called. Even if the arrow function is a method of an object, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," is taken from the context outside the object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Class")),(0,i.kt)("p",{parentName:"li"},"In a base class, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," refers to an instance of the class. In a derived class, ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," refers to an instance of the class only after the parent constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"super")," is called."))),(0,i.kt)("h3",{id:"apply-bind-and-call"},"Apply, Bind and Call"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"apply()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bind()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"call()")," are builtin methods of functions in JavaScript. (They are members of ",(0,i.kt)("a",{parentName:"p",href:"#prototype"},(0,i.kt)("inlineCode",{parentName:"a"},"Function.prototype")),".) The differences between them and direct function invocation are mainly: 1) what the context object, ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),", is pointing to within the function, and 2) the way function parameters are passed in."),(0,i.kt)("p",null,"Here is one simple example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"class Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction sing(employer: string, has: string[]) {\n  const hasParsed = has.map(has => `a ${has}`).join(' and ');\n  console.log(\n    `Hi, my name is ${this.name} and I work in a ${employer}, I've got ${hasParsed}.`\n  );\n}\n\nconst joe = new Person('Joe');\n")),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"sing")," does not work when you try to call it directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function sing(employer: string, has: string[]) {\n  const hasParsed = has.map(has => `a ${has}`).join(' and ');\n  // error-start\n  console.log(\n    `Hi, my name is ${this.name} and I work in a ${employer}, I've got ${hasParsed}.`\n  );\n  `TypeError: Cannot read properties of undefined (reading 'name')`;\n  // error-end\n}\n\nsing('button factory', ['wife', 'dog', 'family']);\n")),(0,i.kt)("p",null,"Let's see how can we use the function with ",(0,i.kt)("inlineCode",{parentName:"p"},"apply"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"call"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"bind"),"."),(0,i.kt)("h4",{id:"applythisarg-any-argarray-any"},(0,i.kt)("inlineCode",{parentName:"h4"},"apply(thisArg: any, argArray?: any[])")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"apply")," calls the function with the first parameter as the ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," context object, and the second parameter as the parameters of the function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"sing.apply(joe, ['button factory', ['wife', 'dog', 'family']]);\n// Hi, my name is Joe and I work in a button factory, I've got a wife and a dog and a family.\n")),(0,i.kt)("h4",{id:"callthisarg-any-argarray-any"},(0,i.kt)("inlineCode",{parentName:"h4"},"call(thisArg: any, ...argArray: any[])")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"call")," calls the function with the first parameter as the ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," context object, and the remaining parameters as the parameters of the function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"sing.call(joe, 'button factory', ['wife', 'dog', 'family']);\n// Hi, my name is Joe and I work in a button factory, I've got a wife and a dog and a family.\n")),(0,i.kt)("h4",{id:"bindthisarg-any"},(0,i.kt)("inlineCode",{parentName:"h4"},"bind(thisArg: any)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"bind")," is the most special among the three, where it creates a new function with the ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," context object referring to a give object for subsequent direct invocations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const joeSings = sing.bind(joe);\njoeSings('button factory', ['wife', 'dog', 'family']);\n// Hi, my name is Joe and I work in a button factory, I've got a wife and a dog and a family.\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Implementing bind"),(0,i.kt)("p",null,"Here is how ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," can be implemented by hand, using ",(0,i.kt)("a",{parentName:"p",href:"#wrapping-a-function"},"a function wrapper pattern"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function bind(func, thisArg) {\n  return function (...args) {\n    return func.apply(thisArg, args);\n  };\n}\n"))),(0,i.kt)("h3",{id:"use-cases-of-function-built-ins"},"Use Cases of Function Built-ins"),(0,i.kt)("p",null,"Well, good to know all this, but you probably have never used them in your daily work. ",(0,i.kt)("del",{parentName:"p"},"Who writes such convoluted code with the actionable object inside the function parameters? Who anyhow changes the ",(0,i.kt)("inlineCode",{parentName:"del"},"this")," object until the point no one knows what ",(0,i.kt)("inlineCode",{parentName:"del"},"this")," really is?")," What's the point of memorizing them if they are not used at all ",(0,i.kt)("del",{parentName:"p"},"except for preparing interviews"),"?"),(0,i.kt)("p",null,"Good point, so here we list some use cases that you may ",(0,i.kt)("del",{parentName:"p"},"or may not")," encounter in future. I mean if you never come to know these functions, you will never think about using them when you encounter a similar situation!"),(0,i.kt)("h4",{id:"inheritance-with-prototype"},"Inheritance with prototype"),(0,i.kt)("p",null,"In inheritance using prototype, you need to use either ",(0,i.kt)("inlineCode",{parentName:"p"},"apply")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," to ensure that the parent function is setting properties of the child object. See ",(0,i.kt)("a",{parentName:"p",href:"#inheritance-chains"},"inheritance with the prototype chain"),". ",(0,i.kt)("del",{parentName:"p"},"To be honest, just use classes.")),(0,i.kt)("h4",{id:"wrapping-a-function"},"Wrapping a function"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"apply")," becomes truly handy when it comes to wrapping a function. Wrapping a function is to create a new function based on an existing function, usually with additional behaviors. For example, the following is a wrapping function to print out function parameters and return value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function wrapWithPrint<T extends any[], U>(func: (...args: T) => U) {\n  return function (...args: T) {\n    console.log(`${func.name} is called with ${args}`);\n    const result = func.apply(this, args) as U;\n    console.log(`${func.name} returns ${result}`);\n    return result;\n  };\n}\n")),(0,i.kt)("p",null,"Let's try this out:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function add(a: number, b: number) {\n  return a + b;\n}\n\nconst wrappedAdd = wrapWithPrint(add);\nwrappedAdd(5, 3);\n// add is called with 5,3\n// add returns 8\n")),(0,i.kt)("p",null,"Now why is ",(0,i.kt)("inlineCode",{parentName:"p"},"apply")," useful here? Because you always want the context object ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," stay the same before and after wrapping. Let's take a look at the example here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"class Person {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  saySomething(to: string) {\n    console.log(`Hi ${to}, my name is ${this.name}.`);\n  }\n}\n\nconst joe = new Person('Joe');\njoe.saySomething = wrapWithPrint(joe.saySomething);\njoe.saySomething('Tony');\n// saySomething is called with Tony\n// Hi Tony, my name is Joe.\n// saySomething returns undefined\n")),(0,i.kt)("p",null,"This example will not work without ",(0,i.kt)("inlineCode",{parentName:"p"},"apply"),"! This is because by calling the function directly, the context object within the function is set to the current context object where the call takes place, in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"globalThis")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"window"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function wrapWithPrint<T extends any[], U>(func: (...args: T) => U) {\n  return function (...args: T) {\n    console.log(`${func.name} is called with ${args}`);\n    const result = func(...args); // this === globalThis\n    console.log(`${func.name} returns ${result}`);\n    return result;\n  };\n}\n")),(0,i.kt)("p",null,"As a result, accessing ",(0,i.kt)("inlineCode",{parentName:"p"},"this.name")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," result in reading property ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"globalThis")," and gives ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),". By using ",(0,i.kt)("inlineCode",{parentName:"p"},"apply")," function, we ensure that ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," is consistent with when the wrapper function is actually called."),(0,i.kt)("h2",{id:"prototype"},"Prototype"),(0,i.kt)("admonition",{title:"Why prototype?",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"For me personally, I would prefer using ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," of class for inheritance, due to its higher readability and maintainability. So why still learn about prototype?"),(0,i.kt)("p",{parentName:"admonition"},"Well, apparently the introduction of class in ES6 (formally ES2015) did not stop prototype from appearing in interviews. Also, prototype is a good to know for the following reasons:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Class is merely syntactical sugar over prototype. Understanding prototype is essential for understanding class inheritance under the hood."),(0,i.kt)("li",{parentName:"ul"},"Class is less optimized compared to prototype implementations, especially with private properties."),(0,i.kt)("li",{parentName:"ul"},"Older browsers do not support class out of the box and class needs to be transpiled into prototype."))),(0,i.kt)("h3",{id:"from-class-to-prototype"},"From Class to Prototype"),(0,i.kt)("p",null,"Let's first write some inheritance with class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"class Animal {\n  name: string;\n  noise: string;\n\n  constructor(name: string, noise: string = 'bar') {\n    this.name = name;\n    this.noise = noise;\n  }\n\n  saySomething() {\n    console.log(`${this.name} says: ${this.noise}`);\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name: string) {\n    super(name, 'meow~');\n  }\n\n  doSomething() {\n    console.log(`${this.name} is sleeping.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name: string) {\n    super(name, 'woof!');\n  }\n\n  doSomething() {\n    console.log(`${this.name} is running around.`);\n  }\n}\n\nconst dog = new Dog('Lele');\ndog.saySomething(); // Lele says: woof!\ndog.doSomething(); // Lele is running around.\n\nconst cat = new Cat('Mimi');\ncat.saySomething(); // Mimi says: meow~\ncat.doSomething(); // Mimi is sleeping.\n")),(0,i.kt)("p",null,"How how to do the same with prototype? Let's start with the parent class, ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal"),"."),(0,i.kt)("p",null,"We first write with the constructor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Animal(name: string, noise: string = 'bar') {\n  this.name = name;\n  this.noise = noise;\n}\n")),(0,i.kt)("p",null,"We also write the method for the parent class and assigning it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," of the constructor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"Animal.prototype.saySomething = function () {\n  console.log(`${this.name} says: ${this.noise}`);\n};\n")),(0,i.kt)("p",null,"That is already sufficient for us to test out if this works."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const bar = new Animal('Foo');\nbar.saySomething(); // Foo says: bar\n")),(0,i.kt)("p",null,"Before we continue, let's pause a while for now to understand what is happening here."),(0,i.kt)("h3",{id:"constructors"},"Constructors"),(0,i.kt)("h4",{id:"initializing-properties"},"Initializing properties"),(0,i.kt)("p",null,"What is a constructor function? It is a function that returns objects with properties initialized in a same way when called multiple times. There is no difference to a normal function and we can do this ourselves:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"showLineNumbers",showLineNumbers:!0},"function getAnimal(name: string, noise: string = 'bar') {\n  // highlight-next-line\n  const newAnimal = {};\n  newAnimal.name = name;\n  newAnimal.noise = noise;\n  // highlight-next-line\n  return newAnimal;\n}\n")),(0,i.kt)("p",null,"However, note that line 2 and line 5 maybe a little bit repetitive to write given that they are necessary in all constructor functions. We hope the constructor functions can just care about assigning values to an object, not initializing or returning it. Therefore, we make use of ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),", an object that exists in function's outer scope and made available to the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Animal(name: string, noise: string = 'bar') {\n  this.name = name;\n  this.noise = noise;\n}\n")),(0,i.kt)("p",null,"Yes, this is exactly the same as the function we have just written previously. But what happens if we use it directly?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"Animal('foo1');\nthis.name; // foo1\nAnimal('foo2');\nthis.name; // foo2\n// Hmm where is animal foo1?\n")),(0,i.kt)("p",null,"All functions at the same level share the same ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," object, so it is impossible to have multiple objects! Here is exactly why we need the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," keyword: to put simply, it creates an object, make ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," of the function that follows to point to this object, and finally return this object when the function finishes executing (assigning the values)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const foo1 = new Animal('foo1');\nfool.name; // foo1\nconst foo2 = new Animal('foo2');\nfoo2.name; // foo2\n// Yay we can have many objects!\n")),(0,i.kt)("h4",{id:"initializing-methods"},"Initializing methods"),(0,i.kt)("p",null,"All seems good right now, let's continue to add our method, ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Animal(name: string, noise: string = 'bar') {\n  this.name = name;\n  this.noise = noise;\n  this.saySomething = function () {\n    console.log(`${this.name} says: ${this.noise}`);\n  };\n}\n\nconst bar = new Animal('Foo');\nbar.saySomething(); // Foo says: bar\n")),(0,i.kt)("p",null,"Great! It works, and you are satisfied with that."),(0,i.kt)("p",null,"But wait a moment. There is one more thing to optimize, but you may not realize it. Let's see what is inside our initialized objects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const bar1 = new Animal('foo1');\nconst bar2 = new Animal('foo2');\nbar1; // { name: 'foo1', noise: 'bar', saySomething: f(), ... }\nbar2; // { name: 'foo2', noise: 'bar', saySomething: f(), ... }\n")),(0,i.kt)("p",null,"Do you notice it? The function ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," duplicates in all objects initialized, although we know that it is not going to differ between objects instantiated with the same constructor. That is going to take up much unnecessary memory space. (Same for ",(0,i.kt)("inlineCode",{parentName:"p"},"noise")," as well, but we will discuss about that later.)"),(0,i.kt)("p",null,"How do we solve this issue? Well, it would be great if we can have a common object that contains the function ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething"),". All objects instantiated by the constructor can just refer to the methods defined in this common object."),(0,i.kt)("p",null,"This common object is known as the prototype."),(0,i.kt)("p",null,"The prototype of objects comes from the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property of functions. The ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property is only used when a function is called as a constructor with ",(0,i.kt)("inlineCode",{parentName:"p"},"new"),": an internal property known as ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," of the new object, also known as the prototype of the object, will be pointing to the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," of the constructor."),(0,i.kt)("admonition",{title:"Too many prototypes!",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The properties ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," are confusing. For clarity, here we outline the difference between the two and denote them differently in this document:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prototype"),': it is a property of a function. It is the target where the prototypes of objects are pointing to. It is mentioned as "the ',(0,i.kt)("inlineCode",{parentName:"li"},"prototype"),' property" in this document.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[[Prototype]]"),": it is an internal property of an object (including a function). It points to the ",(0,i.kt)("inlineCode",{parentName:"li"},"prototype"),' property of object\'s constructor. By "internal", it means that the property is not directly accessible. It is mentioned as "the prototype of the object" in this document.'))),(0,i.kt)("p",null,"Let's change the above code properly by assigning methods to the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property of the constructor."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Animal(name: string, noise: string = 'bar') {\n  this.name = name;\n  this.noise = noise;\n}\nAnimal.prototype.saySomething = function () {\n  console.log(`${this.name} says: ${this.noise}`);\n};\nconst bar1 = new Animal('foo1');\nconst bar2 = new Animal('foo2');\nbar1; // { name: 'foo1', noise: 'bar', [[Prototype]]: Object }\nbar2; // { name: 'foo1', noise: 'bar', [[Prototype]]: Object }\n")),(0,i.kt)("p",null,"If you expand ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," in DevTools' console, you will see:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"[[Prototype]]: {\n  saySomething: f(),\n  constructor: f Animal(name, noise = 'bar'),\n}\n")),(0,i.kt)("p",null,"While it may not be obvious, but ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," is not duplicated anymore and only exists in ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype"),". The one you see is exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype"),", evaluated when ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," is actually expanded."),(0,i.kt)("p",null,"The special thing about ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," internal property is that when you call something like ",(0,i.kt)("inlineCode",{parentName:"p"},"bar.saySomething()"),", it first search for property ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," in the object's own property scope, and if it is not found, search for the property in the object's prototype scope."),(0,i.kt)("p",null,"Maybe you already think that it starts to feel like inheritance. Exactly. Let's move on to chain up the prototypes of objects to achieve the real inheritance that we want."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"Accessing ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"[[Prototype]]")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," is an internal property of objects and cannot be directly accessed with the property accessor ",(0,i.kt)("inlineCode",{parentName:"p"},"."),". To access it, we can use a utility function: ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.getPrototypeOf(...)"),"."),(0,i.kt)("p",{parentName:"admonition"},"With this, we can verify that the ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," of the object is indeed the same instance as the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property of the constructor:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"Object.getPrototypeOf(bar1) === Animal.prototype; // true\n")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"obj.__proto__")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.getPrototypeOf(obj)")," in most JavaScript engines. However, this is ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"},"non-standard and should be avoided"),".")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"Mutating ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"prototype")," property"),(0,i.kt)("p",{parentName:"admonition"},"It is advised not to mutate or reassign the ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property of constructors other than initializing methods, to avoid unexpected or inconsistent behaviors:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const bar = new Animal('Foo');\n\nAnimal.prototype.saySomething = function () {\n  console.log(`${this.name} says nothing.`);\n};\nbar.saySomething(); // Foo says nothing.\n\n// Some time later\nAnimal.prototype.saySomething = function () {\n  console.log(`${this.name} says something!`);\n};\nbar.saySomething(); // Foo says something!\n"))),(0,i.kt)("h3",{id:"inheritance-chains"},"Inheritance Chains"),(0,i.kt)("p",null,"Now how do we chain up prototypes of objects? One thing that immediately comes up in your mind is probably to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.setPrototypeOf")," method. Well, this is half correct: but the real question is what is the object that we want to set new prototype on, and where is this new prototype coming from."),(0,i.kt)("p",null,"One may be temped to set the prototype directly on instantiated objects. If you have followed me until this point, you know that it is not going to work. If we completely alter the prototype of an object, it no longer have access to the properties on the previous prototype, and hence the ability that it used to have. This is obviously not we want:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Cat(name: string) {\n  this.name = name;\n  this.noise = 'meow~';\n}\nCat.prototype.doSomething = function () {\n  console.log(`${this.name} is sleeping.`);\n};\n\nconst cat = new Cat('Mimi');\n// highlight-next-line\nObject.setPrototypeOf(cat, Cat.prototype);\ncat.doSomething(); // Mimi is sleeping.\n// error-start\ncat.saySomething();\n`TypeError: cat.saySomething is not a function`;\n// error-end\n")),(0,i.kt)("p",null,"How do we retain the original properties of the object's prototype, while being able to access new properties? The answer is simply: to use prototype itself. But this time, we are setting the prototype, or the ",(0,i.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," inner property, of the constructor's ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype")," property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Cat(name: string) {\n  // a bit incorrect, but let's fix it later\n  this.name = name;\n  this.noise = 'meow~';\n}\n// highlight-next-line\nObject.setPrototypeOf(Cat.prototype, Animal.prototype);\nCat.prototype.doSomething = function () {\n  console.log(`${this.name} is sleeping.`);\n};\n\nconst cat = new Cat('Mimi');\ncat.doSomething(); // Mimi is sleeping.\ncat.saySomething(); // Mimi says: meow~\n")),(0,i.kt)("p",null,"Let's inspect ",(0,i.kt)("inlineCode",{parentName:"p"},"cat")," in DevTools to understand what is happening:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n  name: 'Mimi',\n  noise: 'meow~',\n  [[Prototype]]: { // Cat.prototype\n    doSomething: f(),\n    constructor: f Cat(name),\n    [[Prototype]]: { // Animal.prototype\n      saySomething: f(),\n      constructor: f Animal(name, noise = 'foo'),\n    },\n  },\n}\n")),(0,i.kt)("p",null,"We have successfully created a prototype chain! When we call ",(0,i.kt)("inlineCode",{parentName:"p"},"cat.saySomething()"),", it first tries to find ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"cat"),"'s own property. When it is not found, it searches within the prototype of ",(0,i.kt)("inlineCode",{parentName:"p"},"cat"),", that is ",(0,i.kt)("inlineCode",{parentName:"p"},"Cat.prototype"),"'s own property. When it is still not found, it searches the prototype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Cat.prototype"),", that is ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype"),"'s own property. Finally, it found ",(0,i.kt)("inlineCode",{parentName:"p"},"saySomething")," there."),(0,i.kt)("admonition",{title:"Own property",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"We refer something's own property as an object's property that does not need to be searched further within the object's prototype. In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"noise")," are own properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"cat"),". We can verify this:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"cat.hasOwnProperty('name'); // true\ncat.hasOwnProperty('noise'); // true\ncat.hasOwnProperty('doSomething'); // false\nObject.getPrototypeOf(cat).hasOwnProperty('doSomething'); // true\n"))),(0,i.kt)("p",null,"We are pretty close to the original class implementation right now. One last question is how do we achieve ",(0,i.kt)("inlineCode",{parentName:"p"},"super()"),", like in child class's constructor?"),(0,i.kt)("p",null,"We follow the same idea as ",(0,i.kt)("inlineCode",{parentName:"p"},"super"),': instead of assigning the initial properties ourselves, we make use of the constructor of the parent "class":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Cat(name: string) {\n  Animal.prototype.constructor.call(this, name, 'meow~');\n}\nObject.setPrototypeOf(Cat.prototype, Animal.prototype);\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"What is ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"call"),"?"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"someFunction.call(someObject, ...)")," is a way to call function ",(0,i.kt)("inlineCode",{parentName:"p"},"someFunction"),", but with the context object ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," within the function pointing to ",(0,i.kt)("inlineCode",{parentName:"p"},"someObject"),"."),(0,i.kt)("p",{parentName:"admonition"},"Why we need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"constructor.call(this, ...)")," here, instead of directly invoking ",(0,i.kt)("inlineCode",{parentName:"p"},"constructor(...)"),"? That is because we want to set the properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," on the instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Cat"),", but not on the instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype"),"."),(0,i.kt)("p",{parentName:"admonition"},"See what happens if we invoke the constructor directly:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function Cat(name: string) {\n  Animal.prototype.constructor(name, 'meow~');\n}\nObject.setPrototypeOf(Cat.prototype, Animal.prototype);\nCat.prototype.doSomething = function () {\n  console.log(`${this.name} is sleeping.`);\n};\n\nconst cat = new Cat('Mimi');\ncat.doSomething(); // Mimi is sleeping.\n\nconst cat2 = new Cat('Miantiao');\ncat2.doSomething(); // Miantiao is sleeping.\ncat.doSomething(); // Miantiao is sleeping.\n// What happened to Mimi???\n")),(0,i.kt)("p",{parentName:"admonition"},"If we inspect ",(0,i.kt)("inlineCode",{parentName:"p"},"cat")," under DevTools, we will realize what is wrong here:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n  // name is not here...?\n  [[Prototype]]: { // Cat.prototype\n    doSomething: f(),\n    constructor: f Cat(name),\n    [[Prototype]]: { // Animal.prototype\n      // highlight-next-line\n      name: 'Miantiao', // name is here!\n      noise: 'meow~',\n      saySomething: f(),\n      constructor: f Animal(name, noise = 'foo'),\n    },\n  }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"The constructor incorrectly sets the properties ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"noise")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," within the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal")," is pointing to ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype"),". When ",(0,i.kt)("inlineCode",{parentName:"p"},"cat2")," is instantiated, it overwrites the property ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," inside ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal.prototype")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"'Mimi'")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"'Miantiao'"),". To prevent this, we need to specify ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," when calling the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal")," to ensure that the properties are assigned correctly.")),(0,i.kt)("h3",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Here is the original class inheritance implemented with prototype:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// class Animal\nfunction Animal(name: string, noise: string = 'bar') {\n  this.name = name;\n  this.noise = noise;\n}\n\nAnimal.prototype.saySomething = function () {\n  console.log(`${this.name} says: ${this.noise}`);\n};\n\n// class Cat\nfunction Cat(name: string) {\n  Animal.prototype.constructor.call(this, name, 'meow~');\n}\n// extends Animal\nObject.setPrototypeOf(Cat.prototype, Animal.prototype);\n\nCat.prototype.doSomething = function () {\n  console.log(`${this.name} is sleeping.`);\n};\n\n// class Dog\nfunction Dog(name: string) {\n  Animal.prototype.constructor.call(this, name, 'woof!');\n}\n// extends Animal\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n\nDog.prototype.doSomething = function () {\n  console.log(`${this.name} is running around.`);\n};\n\nconst dog = new Dog('Lele');\ndog.saySomething(); // Lele says: woof!\ndog.doSomething(); // Lele is running around.\n\nconst cat = new Cat('Mimi');\ncat.saySomething(); // Mimi says: meow~\ncat.doSomething(); // Mimi is sleeping.\n")),(0,i.kt)("h2",{id:"debounce-and-throttle"},"Debounce and Throttle"),(0,i.kt)("p",null,"Debounce and throttle are commonly used techniques to prevent the same action from happening many times within a short period of time, usually to reduce the frequency of API requests or form submissions."),(0,i.kt)("p",null,"The difference between the two is that debounce is to delay the same action until a period of no action has passed, while throttle is to disallow the same action within a period of time after the action has just been triggered."),(0,i.kt)("p",null,"Here, let's begin our example with a simple action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Example() {\n  function triggerEvent() {\n    console.log('Event triggered!');\n  }\n\n  return (\n    <div>\n      <button onClick={() => triggerEvent()}>Click me!</button>\n    </div>\n  );\n}\n")),(0,i.kt)("h3",{id:"debounce"},"Debounce"),(0,i.kt)("p",null,"Let's design a debounce function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"async function debounce(func, time) {\n  // return debounced version of func\n  return func;\n}\n")),(0,i.kt)("p",null,"Our first goal is to delay the function execution until a period of inactivity. Let's implement delaying of the function first with ",(0,i.kt)("a",{parentName:"p",href:"#wrapping-a-function"},"a wrapping function"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Example() {\n  function wait(time) {\n    return new Promise(resolve => {\n      setTimeout(resolve, time);\n    });\n  }\n\n  function debounce(func, time) {\n    return function (...args) {\n      return wait(time).then(() => {\n        func.apply(this, args);\n      });\n    };\n  }\n\n  function triggerEvent() {\n    console.log('Event triggered!');\n  }\n  const debouncedTriggerEvent = debounce(triggerEvent, 1000);\n\n  return (\n    <div>\n      <button onClick={() => debouncedTriggerEvent()}>Click me!</button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"Great! The event is now delayed for 1s before being triggered. However, we have not achieved our goal yet: to cancel the current event if there is a new call within 1s."),(0,i.kt)("p",null,"Let's think about how to do this. First, it would be great if we can cancel the wait if there is a new event call. But the current ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout")," cannot be cancelled half way. How can we make it cancellable?"),(0,i.kt)("p",null,"Let's first modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"wait")," function to return a promise but with a cancel function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Timer() {\n  class CancellablePromise extends Promise {\n    constructor(executor, cancelCallback) {\n      let cancel;\n      function wrapExecutor(executor) {\n        return function (resolve, reject) {\n          cancel = () => {\n            cancelCallback();\n            reject();\n          };\n          executor.call(this, resolve, reject);\n        };\n      }\n      super(wrapExecutor(executor));\n      this.cancel = cancel;\n    }\n  }\n\n  function cancellableWait(time) {\n    let timer = null;\n    return new CancellablePromise(\n      (resolve, reject) => {\n        timer = setTimeout(resolve, time);\n      },\n      () => {\n        timer && clearTimeout(timer);\n      }\n    );\n  }\n\n  const timerPromise = useRef();\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          console.log('Timer starts!');\n          timerPromise.current = cancellableWait(5000);\n          timerPromise.current\n            .then(() => {\n              console.log('5 seconds has passed!');\n            })\n            .catch(() => {\n              console.log('Timer cancelled...');\n            });\n        }}\n      >\n        Start\n      </button>\n      <button\n        onClick={() => {\n          timerPromise.current && timerPromise.current.cancel();\n        }}\n      >\n        Cancel\n      </button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"Wow it works! Now we can use our cancellable wait in the debounce function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Example() {\n  class CancellablePromise extends Promise {\n    constructor(executor, cancelCallback) {\n      let cancel;\n      function wrapExecutor(executor) {\n        return function (resolve, reject) {\n          cancel = () => {\n            cancelCallback();\n            reject();\n          };\n          executor.call(this, resolve, reject);\n        };\n      }\n      super(wrapExecutor(executor));\n      this.cancel = cancel;\n    }\n  }\n\n  function cancellableWait(time) {\n    let timer = null;\n    return new CancellablePromise(\n      (resolve, reject) => {\n        timer = setTimeout(resolve, time);\n      },\n      () => {\n        timer && clearTimeout(timer);\n      }\n    );\n  }\n\n  function debounce(func, time) {\n    let cancellablePromise;\n    return function (...args) {\n      cancellablePromise && cancellablePromise.cancel();\n      cancellablePromise = cancellableWait(time);\n      return cancellablePromise\n        .then(() => {\n          func.apply(this, args);\n        })\n        .catch(() => {\n          // do nothing\n        });\n    };\n  }\n\n  function triggerEvent() {\n    console.log('Event triggered!');\n  }\n  const debouncedTriggerEvent = debounce(triggerEvent, 1000);\n\n  return (\n    <div>\n      <button onClick={() => debouncedTriggerEvent()}>Click me!</button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"An alternative implementation without ",(0,i.kt)("inlineCode",{parentName:"p"},"CancellablePromise"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Example() {\n  function debounce(func, time) {\n    let timer, promise, _resolve;\n    return function (...args) {\n      if (!promise) {\n        promise = new Promise((resolve, reject) => {\n          _resolve = resolve;\n        });\n      }\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        _resolve(func.apply(this, args));\n      }, time);\n      return promise;\n    };\n  }\n\n  function triggerEvent() {\n    console.log('Event triggered!');\n  }\n  const debouncedTriggerEvent = debounce(triggerEvent, 1000);\n\n  return (\n    <div>\n      <button onClick={() => debouncedTriggerEvent()}>Click me!</button>\n    </div>\n  );\n}\n")),(0,i.kt)("h3",{id:"throttle"},"Throttle"),(0,i.kt)("p",null,"Let's design a throttle function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function throttle(func, time) {\n  // return throttled version of func\n  return func;\n}\n")),(0,i.kt)("p",null,"Inside this function, we should keep a flag to indicate whether there is a event triggered recently, and prevent the event from triggering if this is the case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function throttle(func, time) {\n  let recentlyExecuted = false;\n  return function (...args) {\n    if (recentlyExecuted) return;\n    func.apply(this, args);\n    recentlyExecuted = true;\n  };\n}\n")),(0,i.kt)("p",null,"Now we need to reset this flag once this period has passed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function throttle(func, time) {\n  let recentlyExecuted = false;\n  return function (...args) {\n    if (recentlyExecuted) return;\n    func.apply(this, args);\n    recentlyExecuted = true;\n    setTimeout(() => {\n      recentlyExecuted = false;\n    }, time);\n  };\n}\n")),(0,i.kt)("p",null,"Let's try it!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function Example() {\n  function throttle(func, time) {\n    let recentlyExecuted = false;\n    return function (...args) {\n      if (recentlyExecuted) return;\n      func.apply(this, args);\n      recentlyExecuted = true;\n      setTimeout(() => {\n        recentlyExecuted = false;\n      }, time);\n    };\n  }\n\n  function triggerEvent() {\n    console.log('Event triggered!');\n  }\n  const throttledTriggerEvent = throttle(triggerEvent, 1000);\n\n  return (\n    <div>\n      <button onClick={() => throttledTriggerEvent()}>Click me!</button>\n    </div>\n  );\n}\n")),(0,i.kt)("h2",{id:"currying"},"Currying"),(0,i.kt)("p",null,"Currying is to transform a function with many parameters to a function that take in each parameter one by one. With a curried function, a multi-stage process on some data can be split up and chained up easily, without the need to write everything as the function parameters at one go."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function curry(func) {\n  // return a curried function that ...\n  return function curried(...args) {\n    // if having equal (or more) parameters than original function\n    if (args.length >= func.length) {\n      // return result from original function\n      return func.apply(this, args);\n    }\n    // return a function that expect the rest of the parameters\n    return function (...restArgs) {\n      // recursive call with all parameters gathered so far\n      return curried(this, args.concat(restArgs));\n    };\n  };\n}\n")),(0,i.kt)("h2",{id:"behind-the-scene"},"Behind the Scene"),(0,i.kt)("h3",{id:"memory-management"},"Memory Management"),(0,i.kt)("p",null,"In JavaScript, the memory allocation and release are automated. JavaScript uses mark-and-sweep algorithm for garbage collection: from the root (global object), periodically find objects that are reachable from the roots, and garbage collect ones that are not reachable. This prevent the issue of circular references where two objects refer to each other but are not referred from anywhere else. This will result in a memory leak in a naive reference-counting algorithm."),(0,i.kt)("h3",{id:"the-event-loop"},"The Event Loop"),(0,i.kt)("h4",{id:"runtime-concepts"},"Runtime concepts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Stack")),(0,i.kt)("p",{parentName:"li"},"Records currently executing functions. New function called is pushed to the stack and is popped when the function returns. Note that function parameters and local variables declared in a function are stored in the heap instead so that they may remain accessible even after the function has returned.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Heap")),(0,i.kt)("p",{parentName:"li"},"Stores the variables (objects).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Queue")),(0,i.kt)("p",{parentName:"li"},"Stores incoming messages. As the runtime handles an incoming message, it dequeues the message and calls the corresponding function with the message as an input parameter, creating a new stack frame. The handling of messages continue once the stack is emptied."))),(0,i.kt)("h4",{id:"the-event-loop-1"},"The event loop"),(0,i.kt)("p",null,"In browsers, new messages are added to the queue when an event occurs and there is an event listener attached to it. It can also be added using ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout"),". Note the timeout value only indicates the period of time after which the message is added to the queue: hence it is a minimum time rather than a guaranteed time. Also for this reason, ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout")," with a timeout value of 0 always delays the callback until the current function stack finishes executing."),(0,i.kt)("p",null,"Separate runtimes, such as web workers or cross-origin ",(0,i.kt)("inlineCode",{parentName:"p"},"iframes")," keep their own stack, heap, and queue. They can communicate via the ",(0,i.kt)("inlineCode",{parentName:"p"},"postMessage")," method. This also adds a new message to the queue of the target runtime if the runtime is listening ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," events."),(0,i.kt)("admonition",{title:"Macrotasks and Microtasks",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"All of these tasks are known as the ",(0,i.kt)("strong",{parentName:"p"},"macrotasks"),":"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Loading of external scripts via ",(0,i.kt)("inlineCode",{parentName:"li"},"<script />")),(0,i.kt)("li",{parentName:"ul"},"Dispatching UI event such as ",(0,i.kt)("inlineCode",{parentName:"li"},"mousemove")," and triggering handlers"),(0,i.kt)("li",{parentName:"ul"},"When a timeout specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," is reached"),(0,i.kt)("li",{parentName:"ul"},"...")),(0,i.kt)("p",{parentName:"admonition"},"In contrast, these are ",(0,i.kt)("strong",{parentName:"p"},"microtasks"),":"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Executing callbacks (",(0,i.kt)("inlineCode",{parentName:"li"},"then/catch/finally"),") of promises"),(0,i.kt)("li",{parentName:"ul"},"Executing functions with ",(0,i.kt)("inlineCode",{parentName:"li"},"queueMicrotask(func)"))),(0,i.kt)("p",{parentName:"admonition"},"The event loop works as follows:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"Macrotask -> Microtask -> Rendering -> Another Macrotask -> ...\n")),(0,i.kt)("p",{parentName:"admonition"},"Hence, handling of microtasks happens first before handling of another macrotask begins.")))}m.isMDXComponent=!0}}]);